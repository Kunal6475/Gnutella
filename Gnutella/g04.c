#define _POSIX_SOURCE
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/types.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <linux/if_link.h>
#include <openssl/md5.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>

/*This variable stores the value of the port number where it listen to its neighbours request for connection*/
int neighbour_port;
/*This variable stores the value of the port number where it listens for the incoming file request*/
int file_port;
/*This variable stores the value of maximum number of neighbours*/
int max_neighbours;
/*This variable stores the maximum number of hops for the query message*/
int max_ttl;
/*This variable stores the value of the maximum file descriptor*/
int maxfd;
/*This variable stores the value whether it is a seed node*/
int is_seednode;
/*This variable stores the name of the seed nodes file*/
char* seedNode_file;
/*This variable stores the name of the file containing information about the local files*/
char* local_files;
/*This variable contains the information about the where local files are stored*/
char* files_directory;
/*This will contain the list of ips and port number*/
char** seedList;
/*This will contain the list of files and their key words*/
char** file_key_list;
/*This variable will store the local Ip address*/
char* local_ip;
/*This variable will store the local port number*/
char local_port[8];
/*This variable will store the sent messages along with their message ID*/
char* sentpingmessages[25];
/*This variable will store the processed message list-MessageId and the protocoltype concatenated together*/
char* processedmessages[205];
/*This variable will store the backup connections Ip address*/
uint32_t backupIpaddress[10];
/*This variable will store the backup port*/
uint16_t backupPort[10];
/*This variable will store the query message that were generated by me*/
char* sentqueryMessage[25];
/*This variable will store the result of query*/
char* file_display_list[10];
/*This variable stores how many neighbours it can have*/
int max_clients;
/*This variable stores the index of the file display*/
int file_index;
/*This is for displaying what has been read in the configuration file*/
void readconfg_file();
/*This is to start the command prompt loop*/
void g_loop();
/*This is to read the seed node file*/
void readseed_file();
/*This is to read the file name along with the key word values*/
void readfile_keylist();
/*This is to read the command that has been entered by the user*/
char* read_command();
/*This function will parse the command into arguments*/
char** get_commandarguments(char* commandline);
/*This function will get the local ip address*/
void getlocalIp();
/*This function will compute the hash of the message*/
void compute_md5(char* str, unsigned char digest[16]);
/*This function will check whether it can accept any more clients.This will return 1 if it can accept else 0.*/
int canacceptclients(int clients[]);
/*This function will send ping messages to the clients*/
void sendpingmessage(int clients[]);
/*This function will add the messageid to the sent messages list*/
void addtosentpingmessages(unsigned char digest[16]);
/*This function will process the messages accprdingly*/
void processreceivedmessage(int clients[],int index_recivedsocketfd,fd_set * allset);
/*This function will check whether same message has already been processed.This will return 1 if not processed and 0 if processed*/
int messagenotprocessed(char* msg_identifer);
/*This function will determine whether message is generated by others.This will return 1 if it is message is generated from other node 0 if the current node is source of it*/
int messagefromothers(char* messageId);
/*This function will send pong message*/
void sendpongmessage(int clients[],int client_index,char* messageId);
/*This function will forward the ping messages to all the neighbours except from whom he got the message*/
void forwardpingmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value);
/*This function will add to the processed message list*/
void addtoprocessedmessages(char* messageId,char protocol_type);
/*This function will forward the pong message to all the neighbours except from whom he got the message*/
void forwardpongmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,uint16_t port,uint32_t ipaddress);
/*This function will set the default values for the backup port and address*/
void setdefaultbackupvalue();
/*This function will add the ip address and port value to the backup ip address and port value*/
void addbackupvalues(uint16_t port,uint32_t ipaddress);
/*This function will establish connection with the ip address and port that is provided*/
void establishconnection(int clients[],uint16_t port,uint32_t ip_address,fd_set * allset);
/* this function read n bytes */
int readn (int sock, char *msgp, unsigned msgsize);
/*This function will establish new connection with the ip address and port that is provided.If connection is possible it will return 1 else 0*/
int addnewconnection(int clients[],uint16_t port,uint32_t ip_address,fd_set * allset);
/*This method will search for the files in the local store*/
void searchfiles(char * argument);
/*This method will send query message to all its neighbours*/
void sendquerymessage(int clients[],char* searchString);
/*This function will add the messageid to the sent query messages*/
void addtosentquerymessages(unsigned char digest[16]);
/*This function will intialize the list for storing the messages*/
void initialisemessagelist();
/*This function will determine whether query message is generated by others.If self generated it will return 0 else 1*/
int querymessagefromothers(char * messageId);
/*This function will forward the query message to all the neighbours except from whom he got the message*/
void forwardquerymessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,char * searchString);
/*Check if the connection already exist*/
int checkIfConnectionnotexist(int clients[],uint16_t port,uint32_t ipaddress);
/*This function will send query hit message if file exist*/
void sendqueryhitmessage(int clients[],int client_index,char * messageId,char * searchString);
/*This function will forward the query hit message*/
void forwardqueryhitmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,char * no_hits,uint16_t port,uint32_t ipaddress,uint32_t fileSizes[],char * fileNames,unsigned int fileNamelength);
/*This function will check whether the query hit message is already processed.If not it will return 1 else it will return 0*/
int queryhitmessagenotprocessed(char * searchString);
/*This function will send the file*/
void sendFile(int file_sockfd);
/*This function will download the file*/
void downloadfile(char ** command_arguments);

/*This is for debugging whether file content has been read properly*/
/*void displayconfg_value()
{
 printf("Neighbouring port :%d\n",neighbour_port);
 printf("File port :%d\n",file_port);
 printf("Maximum number of neighbours :%d\n",max_neighbours);
 printf("Maximum number of hops :%d\n",max_ttl);
 printf("Is seed node :%d\n",is_seednode);
 printf("Seed node file :%s\n",seedNode_file);
 printf("Local files :%s\n",local_files);
 printf("Files directory :%s\n",files_directory);
}

void displayfilelist_value()
{
 int i=0;
 while(file_key_list[i]!=NULL)
 {
  printf("%s\n",file_key_list[i]);
  i++;
 }
}

void displayseedfile_value()
{
 int i=0;
 while(seedList[i]!=NULL)
 {
  printf("%s\n",seedList[i]);
  i++;
 }
}*/

int main()
{
  readconfg_file();
  readseed_file();
  readfile_keylist();
  /*If it is a seed node then assign max number of clients to 20 or any big number*/
  if (is_seednode==1)
  {
   max_clients=20;
  }
  else
  {
   if (max_neighbours==0)
   {
    fprintf(stderr,"The number of neighbours should be greater than 0.Terminating the application.\n");
    exit(0);
   }
   max_clients=max_neighbours;
  }
  getlocalIp();
  setdefaultbackupvalue();
  initialisemessagelist();
  /*fprintf(stderr,"%s\n",local_ip);*/
  g_loop();
  return 0;
}

/*This function will initialise the message list*/
void initialisemessagelist()
{
  int i;
  for(i=0;i<25;i++)
  {
   sentqueryMessage[i]=NULL;
  }
  for (i=0;i<25;i++)
  {
   sentpingmessages[i]=NULL;
  }
  for(i=0;i<205;i++)
  {
   processedmessages[i]=NULL;
  }
  for(i=0;i<10;i++)
  {
   file_display_list[i]=NULL;
  }
}

/*This function will set the default value for the ip address and port*/
void setdefaultbackupvalue()
{
  int i;
  for(i=0;i<10;i++)
  {
   backupIpaddress[i]=0;
   backupPort[i]=0;
  }
}

/*This function will get the local ip address*/
void getlocalIp()
{
  struct ifaddrs *ifaddr;
  struct ifaddrs *ifa;
  int family, s, n,flags;
  char host[NI_MAXHOST];
  local_ip=malloc(NI_MAXHOST);
  if (getifaddrs(&ifaddr) == -1)
  {
    perror("getifaddrs");
    exit(EXIT_FAILURE);
  }
  /* Walk through linked list, maintaining head pointer so we
  *               can free list later */
  for (ifa = ifaddr, n = 0; ifa != NULL; ifa = ifa->ifa_next, n++)
  {
   if (ifa->ifa_addr == NULL)																                   continue;
   family = ifa->ifa_addr->sa_family;
   flags=ifa->ifa_flags;
   if (family == AF_INET && (flags & IFF_BROADCAST))
   {
    s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);						                    if (s != 0) {
    printf("getnameinfo() failed: %s\n", gai_strerror(s));
    exit(EXIT_FAILURE);
  }
   break;
  }
 
 }
 strncpy(local_ip,host,strlen(host));
 freeifaddrs(ifaddr);
}

/*Read the configuration file and set the values of the variables*/
void readconfg_file()
{
 char* token_delimiter="=";
 char* token_name;
 char* token_value;
 char line[200];
 FILE* file;
 size_t size;
 file=fopen("g04.conf","r");
 if (file!=NULL)
 {
   while(fgets(line,200,file)!=NULL)
   {
     token_name=strtok(line,token_delimiter);
      if (token_name!=NULL)
      {
        token_value=strtok(NULL,token_delimiter);
        if (token_value!=NULL)
        {
          if (strcmp(token_name,"neighborPort")==0)
          {
	    strncpy(local_port,token_value,strlen(token_value)+1);
            neighbour_port=atoi(token_value);
          }
          else if (strcmp(token_name,"filePort")==0)
          {
            file_port=atoi(token_value);
          }
          else if (strcmp(token_name,"NumberOfPeers")==0)
          {
            max_neighbours=atoi(token_value);
          }
          else if (strcmp(token_name,"TTL")==0)
          {
            max_ttl=atoi(token_value);
          }
          else if (strcmp(token_name,"seedNodes")==0)
          {
	   size=strlen(token_value);
	   seedNode_file=malloc(size);
           strncpy(seedNode_file,token_value,size);
          }
          else if (strcmp(token_name,"isSeedNode")==0)
          {
           is_seednode=atoi(token_value);
          }
          else if (strcmp(token_name,"localFiles")==0)
          {
	   size=strlen(token_value);
	   local_files=malloc(size);
           strncpy(local_files,token_value,size);
          }
          else if (strcmp(token_name,"localFilesDirectory")==0)
          {
	   size=strlen(token_value);
	   files_directory=malloc(size);
           strncpy(files_directory,token_value,size);
          }
       }
     }
   }
 }
}

/*This is to read the seed file*/
void readseed_file()
{ 
 FILE* file;
 char* line=malloc(50);
 int position=0;
 if (seedNode_file[strlen(seedNode_file)-1]=='\n')
 {
  seedNode_file[strlen(seedNode_file)-1]='\0';
 }
 file=fopen(seedNode_file,"r");
 seedList=malloc(750);
 if (file!=NULL)
 {
  while(fgets(line,100,file)!=NULL)
  {
    seedList[position]=line;
    position++;
    line=malloc(50);
  }
  free(line);
 }
}

/*This function is to read the file key words*/
void readfile_keylist()
{
 FILE* file;
 char* line=malloc(100);
 int position=0;
 file_key_list=malloc(750);
 if (local_files[strlen(local_files)-1]=='\n')
 {
  local_files[strlen(local_files)-1]='\0';
 }
 file=fopen(local_files,"r");
 if (file!=NULL)
 {
  while(fgets(line,100,file)!=NULL)
  {
   file_key_list[position]=line;
   position++;
   line=malloc(100);
  }
  /*There will be one extra memory that will be allocated. Free that memory*/
  free(line);
 }
}

/*This is to start the command prompt loop*/
void g_loop()
{
 int sockfd;
 int rec_sockfd;
 int con_sockfd;
 int file_sockfd;
 int clients[max_clients];
 int i;
 int len;
 int num;
 int counter;
 int flag=0;
 struct sockaddr_in serveraddr;
 struct sockaddr_in clientaddr;
 struct addrinfo hints;
 struct addrinfo * address_info;
 struct addrinfo * addr_save;
 struct timeval time;
 fd_set allset;
 fd_set res_set;
 char* address;
 char* port;
 char* token_delimiter=" ";
 char* token_connect="GNUTELLA CONNECT/0.4\r\n";
 char* token_connect_ok="GNUTELLA OK\r\n";
 char* read_line;
 char** command_arguments;
 char buf[100];
 fprintf(stderr,"Connecting...\n");
 /*Set the list of client descriptor values to -1*/
 for(i=0;i<max_clients;i++)
 {
  clients[i]=-1;
 }
 /*Set the file descriptor set to empty*/
 FD_ZERO(&allset);
 sockfd=socket(AF_INET,SOCK_STREAM,0);
 if (sockfd<0)
 {
  fprintf(stderr,"Binding Socket could not be created.Terminating application\n");
  exit(0);
 }
 else
 {
  FD_SET(sockfd,&allset);
  maxfd=sockfd;
  /*fprintf(stderr,"Socket id is:%d\n",sockfd);*/
 }

 /*Create the socket for listening to file request*/
 file_sockfd=socket(AF_INET,SOCK_STREAM,0);
 if (file_sockfd<0)
 {
  fprintf(stderr,"Binding socket for listening to file request could not be created.Terminating application\n");
  exit(0);
 }
 else
 {
  FD_SET(file_sockfd,&allset);
  if(maxfd<file_sockfd)
  {
   maxfd=file_sockfd;
  }
  /*fprintf(stderr,"File Socket id is:%d\n",file_sockfd);*/
 }
 
 memset(&serveraddr,0,sizeof(serveraddr));
 serveraddr.sin_port=htons((short)neighbour_port);
 serveraddr.sin_family=AF_INET;
 serveraddr.sin_addr.s_addr=INADDR_ANY;
 i=bind(sockfd,(struct sockaddr *)&serveraddr,sizeof(serveraddr));
 if (i<0)
 {
  perror("Bind");
  fprintf(stderr,"Unable to bind to socket.Terminating application\n");
  exit(0);
 }
 len=sizeof(serveraddr);
 /*getsockname(sockfd,(struct sockaddr *)&serveraddr,(socklen_t *)&len);
 fprintf(stderr,"ip=%s ,port=%d\n",inet_ntoa(serveraddr.sin_addr),htons(serveraddr.sin_port));*/
 listen(sockfd,5);
 memset(&clientaddr,0,sizeof(clientaddr));

 /*For file request do the binding and listen for incoming request*/
 memset(&serveraddr,0,sizeof(serveraddr));
 serveraddr.sin_port=htons((short)file_port);
 serveraddr.sin_family=AF_INET;
 serveraddr.sin_addr.s_addr=INADDR_ANY;
 i=bind(file_sockfd,(struct sockaddr *)&serveraddr,sizeof(serveraddr));
 if (i<0)
 {
  perror("File Socket Bind");
  fprintf(stderr,"Unable to bind to file socket.Terminating application\n");
  exit(0);
 }
 listen(file_sockfd,5);

 /*If it is a seed node and seed file is empty then it should wait for connection*/
 if (is_seednode && seedList[0]==NULL )
 {
  len=sizeof(clientaddr);
  rec_sockfd=accept(sockfd,(struct sockaddr *)&clientaddr,(socklen_t *)&len);
  /*fprintf(stderr,"Recived socket fd:%d\n",rec_sockfd);
  fprintf(stderr,"Remote machine ip=%s, port=%d\n",inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));*/
  num=read(rec_sockfd,buf,100);
  if (num==0)
  {
   fprintf(stderr,"Client closed.Restart the application\n");
   exit(0);
  }
  else
  {
   buf[num]='\0';
   if(strcmp(token_connect,buf)==0)
   {
    write(rec_sockfd,token_connect_ok,13);
    /*Set the client file descriptor in the file descriptor set and add it in client array*/
    FD_SET(rec_sockfd,&allset);
    if (rec_sockfd>maxfd)
    {
     maxfd=rec_sockfd;
    }
    for(i=0;i<max_clients;i++)
    {
     if (clients[i]<0)
     {
      clients[i]=rec_sockfd;
      break;
     }
    }
   }
  }
 }
 else
 {
  for(;;)
  {
    res_set=allset;
    /*We have to accept any connections if they send request otherwise try to connect from the seed node file*/
    time.tv_sec=5;
    time.tv_usec=5; 
    if FD_ISSET(sockfd,&allset)
    {
     /*fprintf(stderr,"I should listen to incoming request\n");*/
    }
    select(maxfd+1,&res_set,NULL,NULL,&time);
    if FD_ISSET(sockfd,&res_set)
    {    
     rec_sockfd=accept(sockfd,(struct sockaddr *)&clientaddr,(socklen_t *)&len);
     num=read(rec_sockfd,buf,100);
     if (num==0)
     {
      fprintf(stderr,"Client closed.\n");
      continue;
     }
     else
     {
      buf[num]='\0';
      if(strcmp(token_connect,buf)==0)
      {
       write(rec_sockfd,token_connect_ok,13);
       /*Set the client file descriptor in the file descriptor set and add it in client array*/
       FD_SET(rec_sockfd,&allset);
       if (rec_sockfd>maxfd)
       {
         maxfd=rec_sockfd;
       }
       for(i=0;i<max_clients;i++)
       {
        if (clients[i]<0)
        {
         clients[i]=rec_sockfd;
          break;
        }
       }
       break;
     }
     }
    }
    else
    {
      i=0;
      while(seedList[i]!=NULL)
      {
       int j;
       int rcv;
       char addressString[100];
       con_sockfd=socket(AF_INET,SOCK_STREAM,0);
       strncpy(addressString,seedList[i],strlen(seedList[i]));
       /*fprintf(stderr,"Address string=%s\n",addressString);*/
       address=strtok(addressString,token_delimiter);
      /* port=strtok(NULL,token_delimiter);*/
       port=strtok(NULL,"\n");
       if (port[strlen(port)-1]=='\n')
       {
        port[strlen(port)-1]='\0';
       }
       memset(&hints,0,sizeof(hints));
       hints.ai_family=AF_INET;
       hints.ai_socktype=SOCK_STREAM;
       if ((rcv=getaddrinfo(address,port,&hints,&address_info))!=0)
       {
        fprintf(stderr,"%s\n",gai_strerror(rcv));
        fprintf(stderr,"\nAddress info could not be obtained for %s\n",address);
        i++;
        continue;
       }
      addr_save=address_info;
      do
      {
       j=connect(con_sockfd,address_info->ai_addr,address_info->ai_addrlen);
       if (j<0)
       {
        /*perror("Connect");*/
        continue;
       }
       else
       {    
        /*printf("Able to connect to remote machine ip=%s , port=%s\n",address,port);
        fprintf(stderr,"Sending connect message=%s\n",token_connect);*/
        write(con_sockfd,token_connect,22);
        num=read(con_sockfd,buf,100);
        if (num==0)
        {
         fprintf(stderr,"The peer closed.\n");
         exit(0);
        }
        else
        {
        buf[num]='\0';
        /*fprintf(stderr,"Message received=%s\n",buf);*/
        if (strcmp(buf,token_connect_ok)==0)
        {
         /*If connection can be established then we should set it in the file descriptor set and also add it in the client list and also change the maxfd accordingly*/
         FD_SET(con_sockfd,&allset);
         if (con_sockfd>maxfd)
         {
          maxfd=con_sockfd;
         }
         for(counter=0;counter<max_clients;counter++)
         {
          if (clients[counter]<0)
	  {
           clients[counter]=con_sockfd;
	   break;
	  }
        }
      }
    }
     flag=1;
     break;
   }

   }while ((address_info=address_info->ai_next)!=NULL);
   freeaddrinfo(addr_save);
   i++;
  }
  
  }
   if (flag==1)
   {
    break;
   }
  }
 }

 /*More than one client should be present at this point of time*/
 /*Add the STDIN file descriptor to all set to monitor user input*/
 FD_SET(STDIN_FILENO,&allset);
 
 /*As the initial connection can be established so free the memory for seed nodes information if it is not a seed node*/
 /* if (!is_seednode)
  {
   while(seedList[i]!=NULL)
   {
    free(seedList[i]);
   }
   free(seedList);
  }*/

 /*Display the prompt*/
 fprintf(stderr,"GO4: ");
 /*If it is not a seed node can still accept nodes send ping messages*/
  if (!is_seednode)
  {
   if (canacceptclients(clients))
   {
    sendpingmessage(clients);
   }
  }
 counter=0;
 for(;;)
 {
  counter++;
  res_set=allset;
  select(maxfd+1,&res_set,NULL,NULL,NULL);
  /*If somebody is trying to connect accept the connection if possible*/
  if (FD_ISSET(sockfd,&res_set))
  {   
   rec_sockfd=accept(sockfd,(struct sockaddr *)&clientaddr,(socklen_t *)&len);
   /*fprintf(stderr,"Recived socket fd:%d\n",rec_sockfd);
   fprintf(stderr,"Remote machine ip=%s, port=%d\n",inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));*/
   num=read(rec_sockfd,buf,100);
   if (num==0)
   {
    fprintf(stderr,"Client closed.\n");    
   }
   else
   {
    buf[num]='\0';
    /*fprintf(stderr,"The message received:%s\n",buf);*/
    if(strcmp(token_connect,buf)==0)
    {
     /*fprintf(stderr,"Peer has send me connect message. I will send ok\n");*/
     if (canacceptclients(clients))
     {
      write(rec_sockfd,token_connect_ok,13);
      /*Set the client file descriptor in the file descriptor set and add it in client array*/
      FD_SET(rec_sockfd,&allset);
      if (rec_sockfd>maxfd)
      {
       maxfd=rec_sockfd;
      }
      for(i=0;i<max_clients;i++)
      {
       if (clients[i]<0)
       {
        clients[i]=rec_sockfd;
        break;
       }
      }
     }
     else
     {
        /*fprintf(stderr,"Can not accept any more clients.Will store it in backup values\n");*/
	addbackupvalues(clientaddr.sin_addr.s_addr,clientaddr.sin_port);
	close(rec_sockfd);
     }
    }
  }
  }
  
  /*If there has been user input process it accordingly*/
  if (FD_ISSET(STDIN_FILENO,&res_set))
  {   
    /*Every time make it Null for each line in command prompt*/
    read_line=NULL;
    command_arguments=NULL;
    read_line=read_command();
    if (read_line!=NULL)
    {
     command_arguments=get_commandarguments(read_line);
    /* int i=0;
     while(command_arguments[i]!=NULL)
     {
      printf("%s\n",command_arguments[i]);
      i++;
     }*/
     if (strcmp(command_arguments[0],"search")==0)
     {
      if(command_arguments[1]!=NULL)
      {
        int i=1;
        char abc[75];
	memset(abc,'\0',75);
        while(command_arguments[i]!=NULL)
	{
	 if (i!=1)
	 {
          strncat(abc," ",1);
	 }
         strncat(abc,command_arguments[i],strlen(command_arguments[i]));
	 i++;
	}
	sendquerymessage(clients,abc);
	searchfiles(abc);
      }
      else
      {
       fprintf(stderr,"Insufficient arguments for search\n");
      }
    }
    else if (strcmp(command_arguments[0],"get")==0)
    {
      if(command_arguments[1]!=NULL)
      {
       downloadfile(command_arguments);
      }
      else
      {
       fprintf(stderr,"Insufficient arguments for get\n");
      }
    }
    else
    {
     fprintf(stderr,"Unrecognized command\n");
    }
  }
  if (read_line!=NULL)
  {
   free(read_line);
  }
  if (command_arguments!=NULL)
  {
   free(command_arguments);
  }
   fprintf(stderr,"G04: ");
  }
  
  /*If there is any message received in the client socket descriptor process accordingly*/
  for(i=0;i<max_clients;i++)
  {
   if (FD_ISSET(clients[i],&res_set))
   {
    processreceivedmessage(clients,i,&allset);  
   }
  }

  /*If there is any message received in file socket descriptor process accordingly*/
  if (FD_ISSET(file_sockfd,&res_set))
  {
   /*fprintf(stderr,"I received a message in file socket fd\n");*/
   sendFile(file_sockfd);
  }

 /*If counter is 5 and it still accpet more clients send the ping messages and try to accept more clients.Then again reset the counter.*/
  if (counter==5)
  {   
   if (!is_seednode)
   {
    if (canacceptclients(clients))
    {
     /*fprintf(stderr,"I will try to generate more neighbours by sending ping\n");*/
     sendpingmessage(clients);
    }
   }
   counter=0;
  }

 }

}

/*This function will send the file*/
void sendFile(int file_sockfd)
{
 int rec_sockfd;
 int i=0;
 struct sockaddr_in clientaddr;
 int len;
 int nread;
 FILE * file;
 uint32_t fileLength=0;
 char requestMessageHeader[10];
 char requestMessageDetail[35];
 char fileName[55];
 char file_path[150];
 char * responseHeader="HTTP 200 OK\r\nServer:Gnutella\r\nContent-type:application/binary\r\nContent-length:";
 char * responseDetail="\r\n\r\n";
 memset(&clientaddr,0,sizeof(clientaddr));
 len=sizeof(clientaddr); 
 rec_sockfd=accept(file_sockfd,(struct sockaddr *)&clientaddr,(socklen_t *)&len);
 /*fprintf(stderr,"Recived socket fd:%d\n",rec_sockfd);
 fprintf(stderr,"Remote machine ip=%s, port=%d\n",inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));*/
 readn(rec_sockfd,requestMessageHeader,8);
 while(fileName[i]!='/')
 {
  readn(rec_sockfd,&fileName[i],1);
  if (fileName[i]=='/')
  {
   break;
  }
  i++;
 }
 fileName[i]='\0';
 readn(rec_sockfd,requestMessageDetail,33);
 if (files_directory[strlen(files_directory)-1]=='\n')
 {
  files_directory[strlen(files_directory)-1]='\0';
 }
 sprintf(file_path,"%s/%s",files_directory,fileName);
 /*fprintf(stderr,"This is the file i will find out in files directory:%s\n",file_path);*/
 file=fopen(file_path,"r");
 if (file!=NULL)
 {
  i=0;
  fseek(file,0L,SEEK_END);
  fileLength=ftell(file);
  char file_content[256];
  /*fprintf(stderr,"The file length is %d",fileLength);*/
  fseek(file,0L,SEEK_SET);
  fileLength=htonl(fileLength);  
  write(rec_sockfd,responseHeader,78);
  write(rec_sockfd,(char *)&fileLength,sizeof(fileLength));
  write(rec_sockfd,responseDetail,4);
  while(1)
  {
   nread=fread(file_content,1,256,file);
   write(rec_sockfd,file_content,nread);
   
   if (nread<256)
   {
    if(feof(file))
    {
     /*fprintf(stderr,"End of file\n");*/
     break;
    }
    if (ferror(file))
    {
     fprintf(stderr,"File read error\n");
     break;
    }
   }
  }
  
  fclose(file); 
  close(rec_sockfd);
 }
 else
 {
  fprintf(stderr,"File could not be opened\n");
 }
}

/*This function will download the file*/
void downloadfile(char ** command_arguments)
{
 int file_fd;
 uint16_t file_downloadport;
 int port;
 uint32_t file_length;
 int k=0;
 int remaining;
 int f_sockfd;
 struct sockaddr_in f_address;
 char * filedownloadString=malloc(100);
 char * filedownloadname;
 char * f_ipaddr;
 char * file_details;
 char * file_requestHeader="GET/get/";
 char * file_requestdetail="/HTTP/1.0\r\nUser-Agent:Gnutella\r\n\r\n";
 char * msg_to_send;
 char  file_content[256];
 char file_path[100];
 char responseHeader[80];
 int index=atoi(command_arguments[1]);
 file_details=file_display_list[index];
 if (file_details==NULL)
 {
   fprintf(stderr,"Local files can not be downloaded\n");
   return;
 }
 sscanf(file_details,"%d|%s",&port,filedownloadString);
 filedownloadname=strtok(filedownloadString,"|");
 f_ipaddr=strtok(NULL,"|");
 file_downloadport=(uint16_t)port;
 f_sockfd=socket(AF_INET,SOCK_STREAM,0);
 if (f_sockfd>0)
 {
  memset(&f_address,0,sizeof(f_address));
  f_address.sin_family=AF_INET;
  f_address.sin_port=file_downloadport;
  inet_aton(f_ipaddr,&f_address.sin_addr);
  if (connect(f_sockfd,(struct sockaddr *)&f_address,sizeof(f_address))<0)
  {
   perror("Connect:");
  }
  else
  {
    msg_to_send=malloc(200);
    sprintf(msg_to_send,"%s%s%s",file_requestHeader,filedownloadname,file_requestdetail);
    /*fprintf(stderr,"Following request I am sending for downloading of file:%s,length=%d\n",msg_to_send,(int)strlen(msg_to_send));*/
    write(f_sockfd,msg_to_send,strlen(msg_to_send));
    free(msg_to_send);
    readn(f_sockfd,responseHeader,78);
    readn(f_sockfd,(char *)&file_length,sizeof(file_length));
    file_length=ntohl(file_length);
    /*fprintf(stderr,"Response Header:%s,file length=%d\n",responseHeader,(int)file_length);*/
    readn(f_sockfd,responseHeader,4);
   
    if (command_arguments[2]==NULL)
    {
     sprintf(file_path,"%s",filedownloadname);
    }
    else
    {
     sprintf(file_path,"%s",command_arguments[2]);
    }
    /*fprintf(stderr,"File path=%s\n",file_path);*/
   
    file_fd=open(file_path,O_RDWR|O_CREAT|O_TRUNC,0777);
    if(file_fd<0)
    {
     perror("File");
     fprintf(stderr,"Download file can not be created\n");
    }
    else
    {
     remaining=file_length;
     k=0;
     while(remaining>0)
     {
      if(remaining>256)
      {        
        readn(f_sockfd,file_content,256);
        write(file_fd,file_content,256);
	remaining=remaining-256;
	k=k+256;
      }
      else
      {
       readn(f_sockfd,file_content,remaining);
       write(file_fd,file_content,remaining);
       remaining=remaining-remaining;
       k=k+remaining;
      }     
     }
    close(file_fd);
   }
  }
 }
 else
 {
  fprintf(stderr,"Socket could not be created to download the file\n");
 }
 free(filedownloadString);
 close(f_sockfd);
}

/*This function will search the files in the local directory*/
void searchfiles(char* argument)
{
 int i;
 char* fileName;
 char* keyWords;
 char buf[1000];
 struct stat filebuf;
 char* file_delimiter=":";
 char* keywords_delimiter="|";
 char* file_key_list_copy[10];
 char* token=malloc(125);
 if (files_directory[strlen(files_directory)-1]=='\n')
 {
  files_directory[strlen(files_directory)-1]='\0';
 }
 /*First clear all the file display list that exist from previous search*/
 for(i=0;i<10;i++)
 {
  if (file_display_list[i]!=NULL)
  {
   free(file_display_list[i]);
   file_display_list[i]=NULL;
  }
 }

 for(i=0;i<10;i++)
 {
  file_key_list_copy[i]=NULL;
 }
 i=0;
 /*Copy the elements of file_key_list to file_key_list_copy*/
 while(file_key_list[i]!=NULL)
 {
  if (strlen(file_key_list[i])>0)
  {
   strncpy(token,file_key_list[i],strlen(file_key_list[i])+1);
   file_key_list_copy[i]=token;
   token=malloc(125);
   i++;
  }
 }
 free(token);

 i=0;
 file_index=0;
 /*Search file in the local store*/
  while(file_key_list_copy[i]!=NULL)
  {
   fileName=strtok(file_key_list_copy[i],file_delimiter);
   keyWords=strtok(NULL,keywords_delimiter);
   if (keyWords[strlen(keyWords)-1]=='\n')
   {
    keyWords[strlen(keyWords)-1]='\0';
   }
   while(keyWords!=NULL)
   {
     if (strcmp(keyWords,argument)==0)
     {
      sprintf(buf,"%s/%s",files_directory,fileName);
      if (stat(buf,&filebuf)<0)
      {
       perror("File");
       fprintf(stderr,"File may not exist in the directory\n");
       break;
      }
      fprintf(stderr,"%d ",file_index);
      fprintf(stderr,"%d ",(int)filebuf.st_size);
      fprintf(stderr,"%s ",fileName);
      fprintf(stderr,"local\n");
      file_index++;
      break;
     }
     keyWords=strtok(NULL,keywords_delimiter);
     if (keyWords!=NULL)
     {
      if (keyWords[strlen(keyWords)-1]=='\n')
      {
       keyWords[strlen(keyWords)-1]='\0';
      }
     }
   }
   i++;
  }
  
  i=0;
  /*Free the memory*/
  while(file_key_list_copy[i]!=NULL)
  {
    free(file_key_list_copy[i]);
    i++;
  }
 
}

/*This function will check whether it can accept any more clients.Will return 1 if it can accept clients.*/
int canacceptclients(int arr[])
{
 int i;
 int flag=0;
 for (i=0;i<max_clients;i++)
 {
  if (arr[i]<0)
  {
   flag=1;
   break;
  }
 }
 return flag;
}

/*This function will read the command that has been entered by the user*/
char* read_command()
{
 int buffersize=75;
 int position=0;
 int character;
 char* buffer=malloc(sizeof(char *)*buffersize);
 do
 {
  character=getchar();
  /*If character is a new line character make it a null terminated string string and return it*/
  if (character=='\n'&& position!=0)
  {
   buffer[position]='\0';
   return buffer;
  }
  else
  {
   buffer[position]=character;
   position++;
  }
 }while(position<74);

 if (position==74)
 {
  buffer[position]='\0';
 }
 return buffer;
}

/*This function will parse the command line into arguments*/
char** get_commandarguments(char* commandline)
{
 int buffer_size=75;
 int position=0;
 char** arguments=malloc(sizeof(char*)*buffer_size);
 char* token;
 char* token_delimiter=" \t\r";

 if (arguments==NULL)
 {
  fprintf(stderr,"Unable to tokenize commands\n");
  return arguments;
 }

 token=strtok(commandline,token_delimiter);
 
 while(token!=NULL)
 {
  arguments[position]=token;
  position++;
  token=strtok(NULL,token_delimiter);
 }

 arguments[position]=NULL;
 return arguments;
}

/*This method will compute the hash of the message and assign it to the message id */
void compute_md5(char *str, unsigned char digest[16])
{
  MD5_CTX ctx;
  MD5_Init(&ctx);
  MD5_Update(&ctx, str, strlen(str));
  MD5_Final(digest, &ctx); 
}

/*This function will send pong message*/
void sendpongmessage(int clients[],int client_index,char* messageId)
{
 uint16_t port;
 /*int i;*/
 char msg_to_send[3];
 struct in_addr address;
 char protocol_type='2';
 char ttl=max_ttl+'0';
 char hops='0';
 uint32_t payload_length=htonl(6);
 msg_to_send[0]=protocol_type;
 msg_to_send[1]=ttl;
 msg_to_send[2]=hops;
 /*fprintf(stderr,"Sending pong message with messageid=");
 for(i=0;i<16;i++)
 {
   fprintf(stderr,"%c",messageId[i]);
 }
 fprintf(stderr,"  and other values: %c%c%c\n",msg_to_send[0],msg_to_send[1],msg_to_send[2]);*/
 inet_aton(local_ip,&address);
 port=htons(neighbour_port);
 write(clients[client_index],messageId,16);
 write(clients[client_index],msg_to_send,3);
 write(clients[client_index],(char *)&payload_length,sizeof(payload_length));
 write(clients[client_index],(char *)&port,sizeof(port));
 write(clients[client_index],(char *)&address.s_addr,4);
}

/*This function will send query hit message if file exist*/
void sendqueryhitmessage(int clients[],int client_index,char * messageId,char * searchString)
{
 uint16_t port;
 int i;
 int j;
 int counter=0;
 int no_hits=0;
 uint32_t fileSizes[10];
 char fileNames[500];
 char msg_to_send[3];
 char nohits_char;
 struct in_addr address;
 /*4 denotes query hit message*/
 char protocol_type='4';
 char ttl=max_ttl+'0';
 char hops='0';
 uint32_t payload_length=0;
 char* fileName;
 char* keyWords;
 char buf[1000];
 struct stat filebuf;
 char* file_delimiter=":";
 char* keywords_delimiter="|";
 char* file_key_list_copy[10];
 char* token=malloc(125);
 msg_to_send[0]=protocol_type;
 msg_to_send[1]=ttl;
 msg_to_send[2]=hops;
 inet_aton(local_ip,&address);
 port=htons(file_port);


 if (files_directory[strlen(files_directory)-1]=='\n')
 {
  files_directory[strlen(files_directory)-1]='\0';
 }

 for(i=0;i<10;i++)
 {
  file_key_list_copy[i]=NULL;
 }
 i=0;
 /*Copy the elements of file_key_list to file_key_list_copy*/
 while(file_key_list[i]!=NULL)
 {
  if (strlen(file_key_list[i])>0)
  {
   strncpy(token,file_key_list[i],strlen(file_key_list[i])+1);
   file_key_list_copy[i]=token;
   token=malloc(125);
   i++;
  }
 }
 free(token);

 i=0;
 /*Search file in the local store*/
  while(file_key_list_copy[i]!=NULL)
  {
   fileName=strtok(file_key_list_copy[i],file_delimiter);
   keyWords=strtok(NULL,keywords_delimiter);
   if (keyWords[strlen(keyWords)-1]=='\n')
   {
    keyWords[strlen(keyWords)-1]='\0';
   }
   while(keyWords!=NULL)
   {
     if (strcmp(keyWords,searchString)==0)
     {
      sprintf(buf,"%s/%s",files_directory,fileName);
      if (stat(buf,&filebuf)<0)
      {
       perror("File");
       fprintf(stderr,"File may not exist in the directory\n");
       break;
      }
      fileSizes[no_hits]=htonl((uint32_t)filebuf.st_size);
      for(j=0;j<=strlen(fileName);j++)
      {
       fileNames[counter]=fileName[j];
       counter++;
      }
      fileNames[counter]='\0';
      counter++;
      no_hits++;
      break;
     }
     keyWords=strtok(NULL,keywords_delimiter);
     if (keyWords!=NULL)
     {
      if (keyWords[strlen(keyWords)-1]=='\n')
      {
       keyWords[strlen(keyWords)-1]='\0';
      }
     }
   }
   i++;
  }
  
  i=0;
  /*Free the memory*/
  while(file_key_list_copy[i]!=NULL)
  {
    free(file_key_list_copy[i]);
    i++;
  }
 
  /*if no of hits is greater than 0 then send the query hit message*/
  if (no_hits>0)
  {
   nohits_char=no_hits+'0';
   payload_length=htonl(1+2+4+(4*no_hits)+counter);
   write(clients[client_index],messageId,16);
   write(clients[client_index],msg_to_send,3);
   write(clients[client_index],(char *)&payload_length,sizeof(payload_length));
   write(clients[client_index],&nohits_char,1);
   write(clients[client_index],(char *)&port,sizeof(port));
   write(clients[client_index],(char *)&address.s_addr,4);
   for(i=0;i<no_hits;i++)
   {
    write(clients[client_index],(char *)&fileSizes[i],4);
   }
   write(clients[client_index],fileNames,counter);
   /*Printing out the query hit message*/
   /*fprintf(stderr,"Sending Query hit message with message id=");
   for(j=0;j<16;j++)
   {
    fprintf(stderr,"%c",messageId[j]);
   }
   fprintf(stderr," and other values %c%c%c%d%c%d%d",msg_to_send[0],msg_to_send[1],msg_to_send[2],(int)payload_length,nohits_char,(int)port,(int)address.s_addr);
   fprintf(stderr," and file sizes");
   for(j=0;j<no_hits;j++)
   {
    fprintf(stderr,"%d",(int)fileSizes[j]);
   }
   fprintf(stderr," and file names:");
   for(j=0;j<counter;j++)
   {
    fprintf(stderr,"%c",fileNames[j]);
   }
   fprintf(stderr,"\n");*/
  }
}

/*This function will send the query message to all its neighbours*/
void sendquerymessage(int clients[],char * searchString)
{
 /*3 will denote query message*/
 int i;
 /*int j;*/
 time_t mytime;
 uint32_t payload_length;
 char msg_to_send[3];
 char * msg_to_hash;
 unsigned char digest[16];
 char protocol_type='3';
 char hops='0';
 char ttl=max_ttl+'0'; 
 payload_length=htonl(strlen(searchString)+1);
 msg_to_send[0]=protocol_type;
 msg_to_send[1]=ttl;
 msg_to_send[2]=hops;
 msg_to_hash=malloc(200);
 mytime=time(NULL);
 sprintf(msg_to_hash,"%c%c%c%d%s%s%s%s",protocol_type,ttl,hops,(int)payload_length,searchString,ctime(&mytime),local_ip,local_port);
 /*fprintf(stderr,"Query Message to hash:%s\n",msg_to_hash);*/
 compute_md5(msg_to_hash,digest);
 /*fprintf(stderr,"Message digest:");
 for(j=0;j<16;j++)
 {
  fprintf(stderr,"%c",digest[j]);
 }
 fprintf(stderr,"\n");*/
 for(i=0;i<max_clients;i++)
 {
  if (clients[i]>0)
  {
   write(clients[i],digest,16);
   write(clients[i],msg_to_send,3);
   write(clients[i],(char *)&payload_length,sizeof(payload_length));
   write(clients[i],searchString,strlen(searchString)+1);
  /* fprintf(stderr,"The query message with digest=%s and message to send=%c%c%c%d%s\n",digest,msg_to_send[0],msg_to_send[1],msg_to_send[2],(int)payload_length,searchString);*/
  }
 }
 addtosentquerymessages(digest);
 free(msg_to_hash);
}

/*This function will send ping messages to the clients*/
void sendpingmessage(int clients[])
{
 /*1 will denote for ping message*/
 int i;
 /*int j;*/
 time_t mytime;
 unsigned char digest[16];
 char protocol_type='1';
 char hops='0';
 char ttl=max_ttl+'0';
 char* msg_to_hash;
 char msg_to_send[3];
 msg_to_send[0]=protocol_type;
 msg_to_send[1]=ttl;
 msg_to_send[2]=hops; 
 /*fprintf(stderr,"Sending ping messages\n");*/
 msg_to_hash=malloc(200);
 mytime=time(NULL);
 sprintf(msg_to_hash,"%c%c%c%s%s%s",protocol_type,ttl,hops,ctime(&mytime),local_ip,local_port);
 /*fprintf(stderr,"Message to hash:%s\n",msg_to_hash);*/
 compute_md5(msg_to_hash,digest);
 /*fprintf(stderr,"Message digest:");
 for(j=0;j<16;j++)
 {
  fprintf(stderr,"%c",digest[j]);
 }
 fprintf(stderr,"\n");*/
 for(i=0;i<max_clients;i++)
 {
  if (clients[i]>0)
  {
   write(clients[i],digest,16);
   write(clients[i],msg_to_send,3);
   /*fprintf(stderr,"The ping message with %s digest and message to send =%c%c%c\n",digest,msg_to_send[0],msg_to_send[1],msg_to_send[2]);*/
  }
 }
 addtosentpingmessages(digest);
 free(msg_to_hash);
}

/*This function will add the message id to sent ping messages list*/
void addtosentpingmessages(unsigned char* digest)
{
  char* messageId=malloc(17);
  int i; 
  for(i=0;i<16;i++)
  {
   messageId[i]=digest[i];
  }
  messageId[16]='\0';
  /*fprintf(stderr,"This is ping messageId that I am storing in list:%s\n",messageId);*/
  for(i=0;i<25;i++)
  {
   if (sentpingmessages[i]==NULL)
   {
    sentpingmessages[i]=messageId;
    break;
   }
  }
}

/*This function will add the messageid to the sent query messages list*/
void addtosentquerymessages(unsigned char* digest)
{
 int i;
 char * messageId=malloc(17);
 for (i=0;i<16;i++)
 {
  messageId[i]=digest[i];
 }
 messageId[16]='\0';
 /*fprintf(stderr,"This is the query message I am storing in the sent query message list:%s\n",messageId);*/
 for(i=0;i<25;i++)
 {
  if (sentqueryMessage[i]==NULL)
  {
   sentqueryMessage[i]=messageId;
   break;
  }
 }
}

/*This function will concatenate the messageId and the protocol type and add to processed message list*/
void addtoprocessedmessages(char * messageId,char protocol_type)
{
 char* processedMessage=malloc(18);
 int i;
 strncpy(processedMessage,messageId,16);
 processedMessage[16]=protocol_type;
 processedMessage[17]='\0';
 for(i=0;i<205;i++)
 {
  if (processedmessages[i]==NULL)
  {
   processedmessages[i]=processedMessage;
   /*fprintf(stderr,"Following processed message was added to my list:%s\n",processedMessage);*/
   break;
  }
 }
}

/*This function will determine whether the ping message is generated by others.If self generated it will return 0 else 1*/
int messagefromothers(char * messageId)
{
 int i;
 int flag=1;
 char* msg_Id=malloc(17);
 strncpy(msg_Id,messageId,16);
 msg_Id[16]='\0';
 /*fprintf(stderr,"This is the ping message I am trying to check whether it is self generated:%s\n",msg_Id);*/
 for (i=0;i<25;i++)
 {
  if (sentpingmessages[i]!=NULL)
  {
   if (strcmp(sentpingmessages[i],msg_Id)==0)
   {
    /*fprintf(stderr,"This is the ping message generated by me\n");*/
    flag=0;
    break;
   }
  }
 }
 free(msg_Id);
 return flag;
}

/*This function will determine whether query message is generated by others.If self generated it will return 0 else 1*/
int querymessagefromothers(char * messageId)
{
 int i;
 int flag=1;
 char * msg_Id=malloc(17);
 strncpy(msg_Id,messageId,16);
 /*fprintf(stderr,"This is the query message I am trying to check whether it is self generated\n");*/
 msg_Id[16]='\0';
 for(i=0;i<25;i++)
 {
  if (sentqueryMessage[i]!=NULL)
  {
   if (strcmp(sentqueryMessage[i],msg_Id)==0)
   {
    /*fprintf(stderr,"This is the query message generated by me\n");*/
    flag=0;
    break;
   }
  }
 }
 free(msg_Id);
 return flag;
}

/*This function will check whether the query hit message is already processed.If not it will return 1 else it will return 0*/
int queryhitmessagenotprocessed(char * searchString)
{
 int i;
 int flag=1;
 for(i=0;i<10;i++)
 {
  if(file_display_list[i]!=NULL)
  {
   if (strcmp(file_display_list[i],searchString)==0)
   {
    /*fprintf(stderr,"This query hit message is already processed\n");*/
    flag=0;
    break;
   }
  }
 }
 return flag;
}

/*This function will check whether message already processed.If not processed it will return 1 else it will return 0*/
int messagenotprocessed(char* msg_identifier)
{
 int i;
 int flag=1;
 char* msg_received=malloc(18);
 strncpy(msg_received,msg_identifier,17);
 msg_received[17]='\0';
 /*fprintf(stderr,"This is the processed message I am trying to find:%s\n",msg_received);*/
 for (i=0;i<205;i++)
 {
  if (processedmessages[i]!=NULL)
  {
   if (strcmp(processedmessages[i],msg_received)==0)
   {    
    flag=0;
    break;
   }
  }
 }
 free(msg_received);
 return flag;
}

/* this function read n bytes */
int readn (int sock, char *msgp, unsigned msgsize)
{
  int rlen;
  int temp;

  do
  {
  rlen = read(sock, msgp, msgsize);
  } while (rlen == -1 && errno == EINTR);
	            
  if (rlen == 0)
  {
    /* connection closed */
    return 0;
  }
  while (rlen <msgsize)
  {
   do 
   {
     temp = read(sock, (msgp+rlen), msgsize-rlen);  
   } while (temp == -1 && errno == EINTR);
   rlen += temp;
  }
  if (rlen == 0)
  {
    /* connection closed */
      return 0;
  }
  if (rlen < msgsize)
  {
   perror(": read");
   fprintf(stderr,"Message elements could not be read properly.This may result in undesired behaviour of the system.\n");
  } 
  return !0;
 }


/*Check if the connection already exist*/
int checkIfConnectionnotexist(int clients[],uint16_t port,uint32_t ipaddress)
{
 int length;
 int flag=1;
 int i;
 struct sockaddr_in neighbour_addr;
 struct sockaddr_in address;
 memset(&address,0,sizeof(address));
 address.sin_addr.s_addr=ipaddress;
 address.sin_port=port;
 for(i=0;i<max_clients;i++)
 {
  if(clients[i]>0)
  {
   length=sizeof(neighbour_addr);
   memset(&neighbour_addr,0,length);
   if (getpeername(clients[i],(struct sockaddr *)(&neighbour_addr),(socklen_t *)&length)<0)
   {
    perror("GetPeerName:");
   }
   if ((neighbour_addr.sin_addr.s_addr==address.sin_addr.s_addr) && (neighbour_addr.sin_port==address.sin_port))
   {
    /*fprintf(stderr,"Connection with Ip address and port already exist\n");*/
    flag=0;
    break;
   }
  }
 }
 return flag;
}

/*This function will process the received messages accordingly*/
void processreceivedmessage(int clients[],int index_receivedsocketfd,fd_set * allset)
{
 int num;
 int i;
 int ttl_value;
 int hop_value;
 char messageId[16];
 char protocol_type[1];
 char ttl[1];
 char hop[1];
 char no_hits;
 int no_hitsvalue;
 uint32_t fileSizes[10];
 char fileNames[500];
 uint32_t payload_length;
 uint32_t ip_address;
 uint16_t port;
 unsigned int fileNamelength;
 char* query_SearchString=NULL;
 char* msg_rcvd_identifier=malloc(17);
 char* token; 
 char* token_to_search;
 num=readn(clients[index_receivedsocketfd],messageId,16);
 if (num==0)
 {
  /*If num is 0 then the client has closed then remove it from client list and also the file desciptor we are monitoring*/
  close(clients[index_receivedsocketfd]);
  FD_CLR(clients[index_receivedsocketfd],allset);
  clients[index_receivedsocketfd]=-1; 
  for(i=0;i<10;i++)
  {
   if(backupIpaddress[i]>0 && backupPort[i]>0)
   {    
     /*We need to try to connect from backup list if any of them is present*/
     /*If connection could be established then make the corresponding values to -1 and break away from the loop*/
     if (addnewconnection(clients,backupPort[i],backupIpaddress[i],allset)>0)
     { 
      /*fprintf(stderr,"I was able to connect through backup list to %d ip address %d port",(int)backupIpaddress[i],(int)backupPort[i]);*/
      backupPort[i]=-1;
      backupIpaddress[i]=-1;
      break;
     }
   }
  }
 }
 else
 {
  if(readn(clients[index_receivedsocketfd],protocol_type,1)==0)
  {
   fprintf(stderr,"Protocol type can not be read properly.Neighbour may have closed\n");
  }
  if(readn(clients[index_receivedsocketfd],ttl,1)==0)
  {
   fprintf(stderr,"TTL value could not be read properly.Neighbour may have closed\n");
  }
  if(readn(clients[index_receivedsocketfd],hop,1)==0)
  {
   fprintf(stderr,"Hop value can not be read properly.Neighbour may have closed\n");
  }

  strncpy(msg_rcvd_identifier,messageId,16);
  msg_rcvd_identifier[16]=protocol_type[0];
  /*fprintf(stderr,"Message received Identifier:");  
  for (i=0;i<17;i++)
  {
   fprintf(stderr,"%c",msg_rcvd_identifier[i]);
  }
  fprintf(stderr,"\n");*/
  ttl_value=ttl[0]-'0';
  ttl_value=ttl_value-1;
  hop_value=hop[0]-'0';
  hop_value=hop_value+1;
  /*fprintf(stderr,"Received-ttl:%c, hop value:%c , After doing necesary opeartions-ttl:%d, hop value:%d\n",ttl[0],hop[0],ttl_value,hop_value);*/
  /*2 is for pong message*/
  if (protocol_type[0]=='2')
  {
   /*struct in_addr a;*/
   /*fprintf(stderr,"Trying to read pong message\n");*/
   readn(clients[index_receivedsocketfd],(char *)&payload_length,sizeof(payload_length));
   readn(clients[index_receivedsocketfd],(char *)&port,sizeof(port));
   readn(clients[index_receivedsocketfd],(char *)&ip_address,sizeof(ip_address));
   /*fprintf(stderr,"payload length=%d,port=%d",ntohl(payload_length),ntohs(port));
   a.s_addr=ip_address;
   fprintf(stderr,"Ip is %s\n",inet_ntoa(a));*/
  }
  /*3 is for query message*/  
  if (protocol_type[0]=='3')
  {
   /*fprintf(stderr,"Trying to read query message\n");*/
   readn(clients[index_receivedsocketfd],(char *)&payload_length,sizeof(payload_length));
   query_SearchString=malloc(ntohl(payload_length));
   readn(clients[index_receivedsocketfd],query_SearchString,ntohl(payload_length));
   /*fprintf(stderr,"Query message length=%d, search string=%s\n",ntohl(payload_length),query_SearchString);*/
  }
  /*4 is for query hit message*/
  if (protocol_type[0]=='4')
  {
   /*struct in_addr ab;*/
   /*fprintf(stderr,"Trying to read Query Hit message\n");*/
   readn(clients[index_receivedsocketfd],(char *)&payload_length,sizeof(payload_length));
   readn(clients[index_receivedsocketfd],&no_hits,sizeof(no_hits));
   readn(clients[index_receivedsocketfd],(char *)&port,sizeof(port));
   readn(clients[index_receivedsocketfd],(char *)&ip_address,sizeof(ip_address));
   no_hitsvalue=no_hits-'0';
   for(i=0;i<no_hitsvalue;i++)
   {
    readn(clients[index_receivedsocketfd],(char *)&fileSizes[i],4);
   }
   fileNamelength=ntohl(payload_length)-1-2-4-(4*no_hitsvalue);
   readn(clients[index_receivedsocketfd],fileNames,fileNamelength);
   /*Printing out the information*/
   /*fprintf(stderr,"Query hit message length=%d,no hits=%c,port=%d",ntohl(payload_length),no_hits,ntohs(port));
   ab.s_addr=ip_address;
   fprintf(stderr,"Ip is %s\n",inet_ntoa(ab));
   fprintf(stderr,"File sizes value are:");
   for(i=0;i<no_hitsvalue;i++)
   {
    fprintf(stderr,"%d",(int)fileSizes[i]);
   }
   fprintf(stderr,"File names string is:");
   for(i=0;i<fileNamelength;i++)
   {
    fprintf(stderr,"%c",fileNames[i]);
   }*/
  }
 
   /*It is a ping message*/
   if (protocol_type[0]=='1')   
   {
    if (messagenotprocessed(msg_rcvd_identifier))
    {
     /*If it is a ping generated by others*/
     if (messagefromothers(messageId))
     {
      /*fprintf(stderr,"This is a ping message generated by others\n");*/
      /*If it can accept clients it will send pong message to the node from which it received*/
      if(canacceptclients(clients))
      {
        /*fprintf(stderr,"I can accept more clients.I will send pong message and forward the ping message to others\n");*/
        sendpongmessage(clients,index_receivedsocketfd,messageId);
        /*It will forward to every neighbour except from he received if the ttl value is still greater than 1*/
	forwardpingmessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value);
      }
      else
      {
        /*fprintf(stderr,"I can not accpet any more clients.I will just forward the message");*/
       /*If it can not accept any more clients it should just forward*/       
	forwardpingmessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value);
      }
      /*addtoprocessedmessages(messageId,protocol_type[0]);*/
     }
     else
     {
      /*fprintf(stderr,"I have got a ping message that was generated by me. So I will not do anything\n");*/
     }
     addtoprocessedmessages(messageId,protocol_type[0]);
    }
    else
    {
     /*fprintf(stderr,"Ping Message already processed.So I will not react to this ping message\n");*/
    }
   }

  /*If it is a query message*/
  if (protocol_type[0]=='3')
  {
   if (messagenotprocessed(msg_rcvd_identifier))
   {
    if (querymessagefromothers(messageId))
    {
     /*Forward the query message to all the neighbours except from whom it is received if ttl value greater than 1*/
       forwardquerymessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value,payload_length,query_SearchString);     
     /*Search for the files and if present send the query hit message*/
      sendqueryhitmessage(clients,index_receivedsocketfd,messageId,query_SearchString); 
    }
    else
    {
     /*fprintf(stderr,"I have got a query message generated by me. So I will not react\n");*/ 
    }    
     /*Add to the processed message list*/
     addtoprocessedmessages(messageId,protocol_type[0]);
   }
   else
   {
    /*fprintf(stderr,"Query message already processed.So I will not react to this query message\n");*/
   }
  }

   /*If it is a query hit message*/
   if (protocol_type[0]=='4')
   {
    /*If the query hit message is in response of others query message then forward it*/
    if (querymessagefromothers(messageId))
    {
     forwardqueryhitmessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value,payload_length,&no_hits,port,ip_address,fileSizes,fileNames,fileNamelength);
    }
    else
    {
     /*If the query hit message is in response to its own query message process it accordingly*/
     int j;
     j=0;
     struct in_addr hostip;
     hostip.s_addr=ip_address;
     token_to_search=malloc(125);
     sprintf(token_to_search,"%d|%s|%s|",port,&fileNames[j],inet_ntoa(hostip));
     /*fprintf(stderr,"This is the query hit token that I will search:%s\n",token_to_search);*/
     if (queryhitmessagenotprocessed(token_to_search))
     {
       for(i=0;i<no_hitsvalue;i++)
       {
        token=malloc(125);
        fprintf(stderr,"%d",file_index);
        fprintf(stderr," %d",ntohl(fileSizes[i]));
        fprintf(stderr," %s",&fileNames[j]);
        fprintf(stderr," %s\n",inet_ntoa(hostip));
        /*Add the port file name and ip address*/
        sprintf(token,"%d|%s|%s|",port,&fileNames[j],inet_ntoa(hostip));
        file_display_list[file_index]=token;
        /*Increment the pointer so that the next file can be read*/
        j=strlen(&fileNames[j])+2;
	/*Increment the file index counter for displaying the file*/
	file_index++;
        /*fprintf(stderr,"This is the token that is being added:%s\n",token);*/
       }
     }
     else
     {
      /*fprintf(stderr,"Query hit message already proceseed.So I will not react to it\n");*/
     }
     /*fprintf(stderr,"Trying to free token to search\n");*/
     free(token_to_search);
     /*fprintf(stderr,"Able to free token to search\n");*/
    }
   }
 
   /*It is a pong message*/
   if (protocol_type[0]=='2')
   {
    /*If it is a seed node it has not generated the ping message so forward it*/
    if (is_seednode)
    {
     forwardpongmessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value,payload_length,port,ip_address);
    }
    else
    {
     /*If the pong message is generated in response to others ping message*/
     if (messagefromothers(messageId))
     {
      forwardpongmessage(clients,index_receivedsocketfd,messageId,protocol_type,ttl_value,hop_value,payload_length,port,ip_address);
     }
     else
     {
      /*If the pong message is in response to its own ping message then if it can accept clients try to make new neighbour*/
      if (canacceptclients(clients))
      {
         if (checkIfConnectionnotexist(clients,port,ip_address))
         {
          /*fprintf(stderr,"As connection does not exist I will connect\n");*/
          establishconnection(clients,port,ip_address,allset); 
         }
        else
        {
         /*fprintf(stderr,"As connection already exits I will not connect\n");*/
        }
      }
      else
      {
       /*fprintf(stderr,"I can not accept any more clients at this point.So i will add backup values\n");*/
       if (checkIfConnectionnotexist(clients,port,ip_address))
       {
         /*fprintf(stderr,"As connection does not exist I will backup the values\n");*/
         addbackupvalues(port,ip_address);
       }
       else
       {
         /*fprintf(stderr,"As same connection exist I will not backup the values\n");*/
       }
      }
     }
   }
  }


 }
 free(msg_rcvd_identifier);

 if (query_SearchString!=NULL)
 {
  free(query_SearchString);
 }

}


/*This function will establish new connection with the ip address and port that is provided.If connection is possible it will return 1 else 0*/
int addnewconnection(int clients[],uint16_t port,uint32_t ip_address,fd_set * allset)
{
  int con_sockfd;
  int j;
  int num;
  int i;
  int flag;
  char buf[100];
  char* token_connect="GNUTELLA CONNECT/0.4\r\n";
  char* token_connect_ok="GNUTELLA OK\r\n";
  struct sockaddr_in neighbour_addr;
  flag=0;
  con_sockfd=socket(AF_INET,SOCK_STREAM,0);
  if (con_sockfd<0)
  {
   perror("Socket");
   return flag;
  }
  memset(&neighbour_addr,0,sizeof(neighbour_addr));
  neighbour_addr.sin_family=AF_INET;
  neighbour_addr.sin_port=port;
  neighbour_addr.sin_addr.s_addr=ip_address;
  j=connect(con_sockfd,(struct sockaddr *)&neighbour_addr,sizeof(neighbour_addr));
  if (j<0)
  {
   perror("Connect");
   return flag;
  }
  else
  {    
    /*printf("Able to connect to remote machine ip=%s , port=%d\n",inet_ntoa(neighbour_addr.sin_addr),port);
    fprintf(stderr,"Sending connect message=%s\n",token_connect);*/
    write(con_sockfd,token_connect,22);
    num=read(con_sockfd,buf,100);
    if (num==0)
    {
     /*fprintf(stderr,"The peer closed.So connection can not be established\n");*/
     return flag;
    }
    else
    {
     buf[num]='\0';
     /*fprintf(stderr,"Message received=%s\n",buf);*/
     if (strcmp(buf,token_connect_ok)==0)
     {
      /*fprintf(stderr,"Connection can be established\n");*/
      /*If connection can be established then we should set it in the file descriptor set and also add it in the client list and also change the maxfd accordingly*/
      FD_SET(con_sockfd,allset);
      if (con_sockfd>maxfd)
      {
       maxfd=con_sockfd;
      }
      flag=1;
      for(i=0;i<max_clients;i++)
      {
        if (clients[i]<0)
        {
         clients[i]=con_sockfd;
         break;
        }
      }
    }
   }
  }
  return flag;
}


/*This function will establish connection with the ip address and port that is provided*/
void establishconnection(int clients[],uint16_t port,uint32_t ip_address,fd_set * allset)
{
  int con_sockfd;
  int j;
  int num;
  int i;
  char buf[100];
  char* token_connect="GNUTELLA CONNECT/0.4\r\n";
  char* token_connect_ok="GNUTELLA OK\r\n";
  struct sockaddr_in neighbour_addr;
  con_sockfd=socket(AF_INET,SOCK_STREAM,0);
  if (con_sockfd<0)
  {
   perror("Socket");
   return;
  }
  memset(&neighbour_addr,0,sizeof(neighbour_addr));
  neighbour_addr.sin_family=AF_INET;
  neighbour_addr.sin_port=port;
  neighbour_addr.sin_addr.s_addr=ip_address;
  j=connect(con_sockfd,(struct sockaddr *)&neighbour_addr,sizeof(neighbour_addr));
  if (j<0)
  {
   perror("Connect");
   return;
  }
  else
  {    
    /*printf("Able to connect to remote machine ip=%s , port=%d\n",inet_ntoa(neighbour_addr.sin_addr),port);
    fprintf(stderr,"Sending connect message=%s\n",token_connect);*/
    write(con_sockfd,token_connect,22);
    num=read(con_sockfd,buf,100);
    if (num==0)
    {
     /*fprintf(stderr,"The peer closed.So connection can not be established\n");*/
     return;
    }
    else
    {
     buf[num]='\0';
     /*fprintf(stderr,"Message received=%s\n",buf);*/
     if (strcmp(buf,token_connect_ok)==0)
     {
      /*fprintf(stderr,"Connection can be established\n");*/
      /*If connection can be established then we should set it in the file descriptor set and also add it in the client list and also change the maxfd accordingly*/
      FD_SET(con_sockfd,allset);
      if (con_sockfd>maxfd)
      {
       maxfd=con_sockfd;
      }
      for(i=0;i<max_clients;i++)
      {
        if (clients[i]<0)
        {
         clients[i]=con_sockfd;
         break;
        }
      }
    }
   }
  }
}

/*This function will add the values to the backup Ip address and backup port*/
void addbackupvalues(uint16_t port,uint32_t ipaddress)
{
 int i;
 for (i=0;i<10;i++)
 {
  if (backupIpaddress[i]<0 && backupPort[i]<0)
  {
   backupIpaddress[i]=ipaddress;
   backupPort[i]=port;
   break;
  }
 }
}

/*This function will forward the pong message to all the neighbours except from whom he got the message*/
void forwardpongmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,uint16_t port,uint32_t ipaddress)
{
 /*char * pong_msg_to_send;*/
 int i;
 char pong_msg_to_send[3];
 pong_msg_to_send[0]=protocol_type[0];
 pong_msg_to_send[1]=ttl_value+'0';
 pong_msg_to_send[2]=hop_value+'0';
 if (ttl_value>0)
 {
  for(i=0;i<max_clients;i++)
  {
   if(i==index_receivedsocketfd)
   {
    continue;
   }
   if (clients[i]>0)
   {
    write(clients[i],messageId,16);
    /*fprintf(stderr,"This is the pong message that I am forwarding:%c%c%c\n",pong_msg_to_send[0],pong_msg_to_send[1],pong_msg_to_send[2]);*/
    write(clients[i],pong_msg_to_send,3);
    write(clients[i],(char *)&payload_length,sizeof(payload_length));
    write(clients[i],(char *)&port,sizeof(port));
    write(clients[i],(char *)&ipaddress,sizeof(ipaddress));
   }
  }
 }
 else
 {
  /*fprintf(stderr,"As ttl value is not greater than 0 I will not forward this pong\n");*/
 }
}

/*This function will forward the query hit message*/
void forwardqueryhitmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,char * no_hits,uint16_t port,uint32_t ipaddress,uint32_t fileSizes[],char * fileNames,unsigned int fileNamelength)
{
 int i;
 int j;
 int no_hitsvalue=*no_hits-'0';
 char queryhit_msg_to_send[3];
 queryhit_msg_to_send[0]=protocol_type[0];
 queryhit_msg_to_send[1]=ttl_value+'0';
 queryhit_msg_to_send[2]=hop_value+'0';
 if (ttl_value>0)
 {
   for(i=0;i<max_clients;i++)
   {
    if(i==index_receivedsocketfd)
    {
     continue;
    }
    if(clients[i]>0)
    {
     write(clients[i],messageId,16);
     write(clients[i],queryhit_msg_to_send,3);
     write(clients[i],(char *)&payload_length,sizeof(payload_length));
     write(clients[i],no_hits,1);
     write(clients[i],(char *)&port,sizeof(port));
     write(clients[i],(char *)&ipaddress,sizeof(ipaddress));
     for(j=0;j<no_hitsvalue;j++)
     {
      write(clients[i],(char *)&fileSizes[j],4);
     }
     write(clients[i],fileNames,fileNamelength);
     /*Printing out the query hit message that I am forwarding*/
     /*fprintf(stderr,"This is the query hit message I am forwarding:%c%c%c%d%c%d%d",queryhit_msg_to_send[0],queryhit_msg_to_send[1],queryhit_msg_to_send[2],ntohl(payload_length),*no_hits,(int)ntohs(port),(int)ntohl(ipaddress));
     fprintf(stderr,"File sizes are:");
     for(j=0;j<no_hitsvalue;j++)
     {
      fprintf(stderr,"%d",(int)fileSizes[j]);
     }
     fprintf(stderr,"File Names:");
     for(j=0;j<fileNamelength;j++)
     {
      fprintf(stderr,"%c",fileNames[j]);
     }*/
    }
   }
 }
 else
 {
  /*fprintf(stderr,"As ttl value is not greater than 0 I will not forward the query hit message\n");*/
 }
}

/*This function will forward the query message to all the neighbours except from whom he got the message*/
void forwardquerymessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value,uint32_t payload_length,char * searchString)
{
 int i;
 char query_msg_to_send[3];
 query_msg_to_send[0]=protocol_type[0];
 query_msg_to_send[1]=ttl_value+'0';
 query_msg_to_send[2]=hop_value+'0';
 if (ttl_value>0)
 {
  for(i=0;i<max_clients;i++)
  {
   if (i==index_receivedsocketfd)
   {
    continue;
   }
   if (clients[i]>0)
   {
    write(clients[i],messageId,16);
    /*fprintf(stderr,"this is the query message I am forwarding:%c%c%c%d%s",query_msg_to_send[0],query_msg_to_send[1],query_msg_to_send[2],(int)payload_length,searchString);*/
    write(clients[i],query_msg_to_send,3);
    write(clients[i],(char *)&payload_length,sizeof(payload_length));
    write(clients[i],searchString,ntohl(payload_length));
   }
  }
 }
 else
 {
  /*fprintf(stderr,"As ttl value is not greater than 0 I will not forward this query message\n");*/
 }
}

/*This function will forward the ping message to all the neighbours except from whom he got the message*/
void forwardpingmessage(int clients[],int index_receivedsocketfd,char * messageId,char * protocol_type,int ttl_value,int hop_value)
{
  /*char * ping_msg_to_send;*/
  int i;
  char ping_msg_to_send[3];
  ping_msg_to_send[0]=protocol_type[0];
  ping_msg_to_send[1]=ttl_value+'0';
  ping_msg_to_send[2]=hop_value+'0';
  if (ttl_value>0)
  {
    for(i=0;i<max_clients;i++)
    {
      if(i==index_receivedsocketfd)
      {
       continue;
      }
      if (clients[i]>0)
      {
       write(clients[i],messageId,16);
       /*fprintf(stderr,"This is the ping message that I am forwarding:%c%c%c\n",ping_msg_to_send[0],ping_msg_to_send[1],ping_msg_to_send[2]);*/
       write(clients[i],ping_msg_to_send,3);
      }
    }
  }
  else
  {
   /*fprintf(stderr,"As ttl value is less than 0 I will not forward this ping\n");*/
  }
}
